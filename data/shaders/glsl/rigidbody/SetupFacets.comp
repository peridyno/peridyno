#version 450
#extension GL_GOOGLE_include_directive : enable
#include "SharedData.glsl"
#include "../math/Quat.glsl"

struct Vertex {
	vec4 pos;
	vec4 uv;
	vec4 normal;
};

layout(std430, binding = 0) buffer VertexOut {
	Vertex vertexOut[ ];
};

layout(std430, binding = 1) buffer IndexOut {
	uint indexOut[ ];
};

layout(std430, binding = 2) buffer BoxIn {
	Box boxIn[ ];
};

layout(std430, binding = 3) buffer CapsuleIn {
	Capsule capsuleIn[ ];
};

layout(std430, binding = 4) buffer SphereIn {
	Sphere sphereIn[ ];
};

layout (binding = 5) uniform UniformOffset {
	ElementOffset eleOffset;
} params;

layout (local_size_x = 32) in;

layout (push_constant) uniform PushConsts {
	uint totalNum;
} pushConsts;

void setupBoxFace(
	uint index,
	vec3 v0,
	vec3 v1,
	vec3 v2,
	vec3 v3,
	uint skip, 
	uint offset)
{
	vec3 e0 = v1 - v0;
	vec3 e1 = v3 - v0;

	vec3 normal = normalize(cross(e1,e0));

	vertexOut[skip*index + offset].pos = vec4(v0, 1);
	vertexOut[skip*index + offset].uv = vec4(0);
	vertexOut[skip*index + offset].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 1].pos = vec4(v1, 1);
	vertexOut[skip*index + offset + 1].uv = vec4(0);
	vertexOut[skip*index + offset + 1].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 2].pos = vec4(v2, 1);
	vertexOut[skip*index + offset + 2].uv = vec4(0);
	vertexOut[skip*index + offset + 2].normal = vec4(normal, 0);

	indexOut[skip*index + offset] = skip*index + offset;
	indexOut[skip*index + offset + 1] = skip*index + offset + 1;
	indexOut[skip*index + offset + 2] = skip*index + offset + 2;


	vertexOut[skip*index + offset + 3].pos = vec4(v0, 1);
	vertexOut[skip*index + offset + 3].uv = vec4(0);
	vertexOut[skip*index + offset + 3].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 4].pos = vec4(v2, 1);
	vertexOut[skip*index + offset + 4].uv = vec4(0);
	vertexOut[skip*index + offset + 4].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 5].pos = vec4(v3, 1);
	vertexOut[skip*index + offset + 5].uv = vec4(0);
	vertexOut[skip*index + offset + 5].normal = vec4(normal, 0);

	indexOut[skip*index + offset + 3] = skip*index + offset + 3;
	indexOut[skip*index + offset + 4] = skip*index + offset + 4;
	indexOut[skip*index + offset + 5] = skip*index + offset + 5;
}

void setupCapsuleFace(
	uint index,
	vec3 v0,
	vec3 v1,
	vec3 v2,
	vec3 v3,
	uint skip, 
	uint offset)
{
	vec3 e0 = v1 - v0;
	vec3 e1 = v3 - v0;

	vec3 normal = normalize(cross(e1,e0));

	vertexOut[skip*index + offset].pos = vec4(v0, 1);
	vertexOut[skip*index + offset].uv = vec4(0);
	vertexOut[skip*index + offset].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 1].pos = vec4(v1, 1);
	vertexOut[skip*index + offset + 1].uv = vec4(0);
	vertexOut[skip*index + offset + 1].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 2].pos = vec4(v2, 1);
	vertexOut[skip*index + offset + 2].uv = vec4(0);
	vertexOut[skip*index + offset + 2].normal = vec4(normal, 0);

	indexOut[skip*index + offset] = skip*index + offset;
	indexOut[skip*index + offset + 1] = skip*index + offset + 1;
	indexOut[skip*index + offset + 2] = skip*index + offset + 2;


	vertexOut[skip*index + offset + 3].pos = vec4(v0, 1);
	vertexOut[skip*index + offset + 3].uv = vec4(0);
	vertexOut[skip*index + offset + 3].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 4].pos = vec4(v2, 1);
	vertexOut[skip*index + offset + 4].uv = vec4(0);
	vertexOut[skip*index + offset + 4].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 5].pos = vec4(v3, 1);
	vertexOut[skip*index + offset + 5].uv = vec4(0);
	vertexOut[skip*index + offset + 5].normal = vec4(normal, 0);

	indexOut[skip*index + offset + 3] = skip*index + offset + 3;
	indexOut[skip*index + offset + 4] = skip*index + offset + 4;
	indexOut[skip*index + offset + 5] = skip*index + offset + 5;
}

void setupCapsuleFace(
	uint index,
	vec3 v0,
	vec3 v1,
	vec3 v2,
	uint skip, 
	uint offset)
{
	vec3 e0 = v1 - v0;
	vec3 e1 = v2 - v0;

	vec3 normal = normalize(cross(e1,e0));

	vertexOut[skip*index + offset].pos = vec4(v0, 1);
	vertexOut[skip*index + offset].uv = vec4(0);
	vertexOut[skip*index + offset].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 1].pos = vec4(v1, 1);
	vertexOut[skip*index + offset + 1].uv = vec4(0);
	vertexOut[skip*index + offset + 1].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 2].pos = vec4(v2, 1);
	vertexOut[skip*index + offset + 2].uv = vec4(0);
	vertexOut[skip*index + offset + 2].normal = vec4(normal, 0);

	indexOut[skip*index + offset] = skip*index + offset;
	indexOut[skip*index + offset + 1] = skip*index + offset + 1;
	indexOut[skip*index + offset + 2] = skip*index + offset + 2;
}

void setupSphereFace(
	uint index,
	vec3 v0,
	vec3 v1,
	vec3 v2,
	uint skip, 
	uint offset)
{
	vec3 e0 = v1 - v0;
	vec3 e1 = v2 - v0;

	vec3 normal = normalize(cross(e1,e0));

	vertexOut[skip*index + offset].pos = vec4(v0, 1);
	vertexOut[skip*index + offset].uv = vec4(0);
	vertexOut[skip*index + offset].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 1].pos = vec4(v1, 1);
	vertexOut[skip*index + offset + 1].uv = vec4(0);
	vertexOut[skip*index + offset + 1].normal = vec4(normal, 0);

	vertexOut[skip*index + offset + 2].pos = vec4(v2, 1);
	vertexOut[skip*index + offset + 2].uv = vec4(0);
	vertexOut[skip*index + offset + 2].normal = vec4(normal, 0);

	indexOut[skip*index + offset] = skip*index + offset;
	indexOut[skip*index + offset + 1] = skip*index + offset + 1;
	indexOut[skip*index + offset + 2] = skip*index + offset + 2;
}

void main() 
{
	uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	if (index >= pushConsts.totalNum) 
		return;

	ElementOffset eleOffset = params.eleOffset;

	if (index < eleOffset.box_bound)
	{
		uint bId = index;
		vec3 c = boxIn[bId].center.xyz;

		vec3 halfLength = boxIn[bId].halfLength.xyz;
		vec3 hx = quat_rotate(boxIn[bId].rot, vec3(halfLength.x, 0, 0));
		vec3 hy = quat_rotate(boxIn[bId].rot, vec3(0, halfLength.y, 0));
		vec3 hz = quat_rotate(boxIn[bId].rot, vec3(0, 0, halfLength.z));

		vec3 hyz = hy + hz;
		vec3 hxy = hx + hy;
		vec3 hxz = hx + hz;
		//vec3 h = rotateVector(vec4(0, 0, 0, 1), boxIn[index].halfLength.xyz);
		vec3 v0 = c - hx - hyz; //vec3(c.x - h.x, c.y - h.y, c.z - h.z);
		vec3 v1 = c + hx - hyz; //vec3(c.x + h.x, c.y - h.y, c.z - h.z);
		vec3 v2 = c + hxz - hy; // vec3(c.x + h.x, c.y - h.y, c.z + h.z);
		vec3 v3 = c - hxy + hz; //vec3(c.x - h.x, c.y - h.y, c.z + h.z);

		vec3 v4 = c - hxz + hy; //vec3(c.x - h.x, c.y + h.y, c.z - h.z);
		vec3 v5 = c + hxy - hz; //vec3(c.x + h.x, c.y + h.y, c.z - h.z);
		vec3 v6 = c + hx + hyz; //vec3(c.x + h.x, c.y + h.y, c.z + h.z);
		vec3 v7 = c - hx + hyz; //vec3(c.x - h.x, c.y + h.y, c.z + h.z);

		uint skip = 36;
		uint offset = 0;
		vec3 tv0, tv1, tv2, tv3;

		// face 0: v0, v1, v2, v3
		setupBoxFace(bId, v0, v1, v2, v3, skip, offset);
		
		offset += 6;
		setupBoxFace(bId, v0, v4, v5, v1, skip, offset);

		offset += 6;
		setupBoxFace(bId, v4, v7, v6, v5, skip, offset);

		offset += 6;
		setupBoxFace(bId, v1, v5, v6, v2, skip, offset);

		offset += 6;
		setupBoxFace(bId, v2, v6, v7, v3, skip, offset);

		offset += 6;
		setupBoxFace(bId, v0, v3, v7, v4, skip, offset);
	}
	else if (index < eleOffset.capsule_bound)
	{
		uint cId = index - eleOffset.box_bound;

		float halfLength = capsuleIn[cId].halfLength;
		float radius = capsuleIn[cId].radius;
		vec3 c = capsuleIn[cId].center.xyz;

		vec3 nx = quat_rotate(capsuleIn[cId].rot, vec3(1, 0, 0));
		vec3 ny = quat_rotate(capsuleIn[cId].rot, vec3(0, 1, 0));
		vec3 nz = quat_rotate(capsuleIn[cId].rot, vec3(0, 0, 1));

		vec3 vx0 = c - nx * (halfLength + radius);
		vec3 vx0y0 = c - nx * halfLength - ny * radius;
		vec3 vx0y1 = c - nx * halfLength + ny * radius;
		vec3 vx0z0 = c - nx * halfLength - nz * radius;
		vec3 vx0z1 = c - nx * halfLength + nz * radius;

		vec3 vx1 = c + nx * (halfLength + radius);
		vec3 vx1y0 = c + nx * halfLength - ny * radius;
		vec3 vx1y1 = c + nx * halfLength + ny * radius;
		vec3 vx1z0 = c + nx * halfLength - nz * radius;
		vec3 vx1z1 = c + nx * halfLength + nz * radius;

		uint offset = 36 * eleOffset.box_bound;
		uint skip = 48;

		setupCapsuleFace(cId, vx1, vx1y0, vx1z0, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx1, vx1z0, vx1y1, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx1, vx1y1, vx1z1, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx1, vx1z1, vx1y0, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx0, vx0y0, vx0z1, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx0, vx0z1, vx0y1, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx0, vx0y1, vx0z0, skip, offset);

		offset += 3;
		setupCapsuleFace(cId, vx0, vx0z0, vx0y0, skip, offset);


		offset += 3;
		setupCapsuleFace(cId, vx1y1, vx0y1, vx0z1, vx1z1, skip, offset);

		offset += 6;
		setupCapsuleFace(cId, vx1z1, vx0z1, vx0y0, vx1y0, skip, offset);

		offset += 6;
		setupCapsuleFace(cId, vx1y0, vx0y0, vx0z0, vx1z0, skip, offset);

		offset += 6;
		setupCapsuleFace(cId, vx1z0, vx0z0, vx0y1, vx1y1, skip, offset);
	}
	else if (index < eleOffset.sphere_bound)
	{
		uint sId = index - eleOffset.capsule_bound;
		vec3 c = sphereIn[sId].center;
	
		float radius = sphereIn[sId].radius;
		vec3 hx = quat_rotate(sphereIn[sId].rot, vec3(radius, 0, 0));
		vec3 hy = quat_rotate(sphereIn[sId].rot, vec3(0, radius, 0));
		vec3 hz = quat_rotate(sphereIn[sId].rot, vec3(0, 0, radius));

		vec3 vx0 = c - hx;
		vec3 vx1 = c + hx;
		vec3 vy0 = c - hy;
		vec3 vy1 = c + hy;
		vec3 vz0 = c - hz;
		vec3 vz1 = c + hz;

		uint skip = 24;
		uint offset = 36 * eleOffset.box_bound + 48 * (eleOffset.capsule_bound - eleOffset.box_bound);
		
		setupSphereFace(sId, vy1, vx1, vz0, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy1, vz0, vx0, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy1, vx0, vz1, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy1, vz1, vx1, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy0, vz0, vx1, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy0, vx0, vz0, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy0, vz1, vx0, skip, offset);

		offset += 3;
		setupSphereFace(sId, vy0, vx1, vz1, skip, offset);
	}
}